# Open WebUI MCP接続問題 トラブルシューティングおよび修正ドキュメント

## 概要

Open WebUI上で設定したMCPサーバー（`clab-ai`）をチャット画面のツールから呼び出そうとした際、**`Failed to connect to MCP server 'clab-ai'`** というエラーが継続して発生し、ツールの利用ができない事象が発生しました。

多角的な調査の結果、このエラー表示の裏には**3つの独立した根本原因（バグ・環境依存・実装仕様）が同時に存在しており、互いに問題を隠蔽し合っていた**ことが判明しました。

このドキュメントでは、根本原因の特定プロセスと、適用した各修正策について記録します。

---

## 発生していた3つの根本原因と修正内容

### Issue 1: Open WebUI側の非標準的なSSEクライアント実装
* **原因:** 
  Open WebUIのMCPクライアント実装（`/app/backend/open_webui/utils/mcp/client.py`）が、公式の `mcp.client.sse` ではなく、非標準の `streamablehttp_client` を利用してSSE通信を確立しようとしていました。これにより、標準的な構成で構築された `mcp-bridge` サーバーとの間でプロトコルレベルの非互換性が生じ、通信が成立していませんでした。
* **修正策:**
  Open WebUIの `client.py` をパッチし、公式ライブラリの標準である `sse_client` を利用して通信するようにルーティングを書き換えました。このパッチファイル（`setup/open_webui_mcp_client.py`）を `docker-compose.yml` の `volumes` を用いてコンテナ内にマウントし、本体コードを上書きしました。

### Issue 2: MCP Bridgeコンテナ内の依存パッケージ・権限不足
* **原因:**
  MCPクライアントからの接続が一見通るようになった後、実際に「ツール一覧の取得（list_tools）」や「ツールの実行」を行うフェーズにおいて、バックエンドの `mcp-bridge` コンテナ内部でコマンドエラーが発生していました。
  ツールの実体は `sudo clab inspect` や `docker exec` といったホスト側の機能を利用するものでしたが、コンテナ内に `sudo`、`curl`、そして `containerlab` 本体がインストールされておらず、また非rootユーザーで稼働していたため、権限エラーとコマンド不在エラーでクラッシュしていました。
* **修正策:**
  `mcp-bridge/Dockerfile` を修正し、`curl`、`sudo`、および `containerlab` のインストール処理を追加しました。また、コンテナの実行ユーザーを非rootからrootへ変更してビルドし直すことで、Dockerソケット経由のネットワーク・コンテナ操作の権限を確保しました。

### Issue 3: 空のAPIキーによる不正なHTTPヘッダーと、エラーの握り潰し（最大の罠）
* **原因:**
  上記2つを修正してCLIを通じた直接通信テストは成功するようになったにも関わらず、Open WebUIのUI（チャット画面）経由では依然として「Failed to connect」が発生し続けました。
  調査の結果、UIのツール設定画面で**「APIキーを空欄のまま保存」**していたことが原因でした。
  Open WebUIの `middleware.py` の仕様により、認証タイプがBearerの場合、空欄であっても `Authorization: Bearer `（末尾に半角スペースがあり、トークンがない状態）という**不正な形式のHTTPヘッダー**を強制的に送信していました。これを受け取った内部の通信ライブラリ（`httpx/httpcore`）が `LocalProtocolError` を起こしてパニックになり、接続が即座に落ちていました。
  * **エラー隠蔽のバグ:** 最も厄介だったのは、このエラーが発生する例外処理ブロック (`except Exception as e:`) において、ログ出力が `log.debug(e)` となっており、**標準のINFOレベルのコンテナログにはエラーの痕跡が一切出力されず完全に隠蔽されていた**ことです。
* **修正策:**
  1. `clab-open-webui` コンテナ内の `/app/backend/open_webui/utils/middleware.py` に直接パッチを当て、APIキーが空欄（`""`）の場合は `Authorization` ヘッダー自体を生成しないよう条件分岐（`if key:`）を追加しました。
  2. また、例外に関するエラーログを `log.error(traceback.format_exc())` として出力するよう強化し、将来のデバッグが容易になるようにしました。

---

## トラブルシューティングの経緯まとめ

1. **Issue 1 対応:** 通信方式のズレを疑い、`docker-compose.yml`でパッチをマウント。
2. **Issue 2 対応:** パッチを当てたにも関わらず接続に失敗するためバックエンドを調査。`mcp-bridge` 側で `sudo clab` 等を実行するための依存関係が足りないことを見つけ、Dockerfileを修正して再ビルド。
3. **Issue 3 対応 (Phase 1/ログ強化):** バックエンドに入ってCLIスクリプトでテストすると通信・ツール実行ともに100%成功し、UIからのみ失敗することが判明。UIのチャット実行フローを司る `middleware.py` のソースコードを特定し、エラーが `log.debug` で隠されていることを突き止めました。
4. **Issue 3 対応 (Phase 2/根本対応):** ログレベルを強制的に上げて詳細なスタックトレースを出力させた結果、`Illegal header value b'Bearer '` という真のエラーメッセージを捕捉。Bearerトークンの取り扱いを行っている箇所を修正し、最終的な疎通に至りました。

## 現在のステータス

* **完了:** Open WebUIのチャット画面から `clab-ai` ツールを呼び出し、Containerlab環境（basic-bgpなど）のFRRコンテナに対して BGP Summary やインターフェース情報を正しく取得・チャットに反映することが可能になりました。これにより、AIと直接ネットワーク構成を対話・トラブルシュート可能な環境が完全に構築されました。
